from cogeneration.util.base_classes import StrEnum


class DatasetColumns(StrEnum):
    """Columns in the training/synthetic/redesign/test metadata CSVs"""

    pdb_name = "pdb_name"
    raw_path = "raw_path"  # original PDB file (optional)
    processed_path = "processed_path"  # pkl file
    quaternary_category = "quaternary_category"
    oligomeric_count = "oligomeric_count"  # num non-unique sequences
    oligomeric_detail = "oligomeric_detail"  # per-unique seq details
    num_chains = "num_chains"
    seq_len = "seq_len"  # total number of atoms
    modeled_seq_len = "modeled_seq_len"  # max - min res number
    moduled_num_res = "moduled_num_res"  # (new) num residues in modeled structure
    coil_percent = "coil_percent"
    helix_percent = "helix_percent"
    strand_percent = "strand_percent"
    radius_gyration = "radius_gyration"

    # TODO add in process_pdb_files if provided
    resolution = "resolution"
    structure_method = "structure_method"

    # cluster metadata (added by loading clusters csv)
    cluster = "cluster"

    # redesign columns
    example = "example"
    best_seq = "best_seq"  # best 1 redesign per structure
    best_rmsd = "best_rmsd"

    # added during load
    index = "index"


class DatasetProteinColumns(StrEnum):
    """
    Information about the protein, pickled in `processed_path`, or from parsing a Protein / Chain.
    Most of these values are defined by `process_chain` and `parse_chain_feats`.

    The saved proteins contain all molecules / residues, and is of length P.
    `modeled_idx` is length N, and defines which residues are modeled.
    It is used to select these out of the pickled file, then dropped almost immediately in loading / processing.

    Most fields and values seem straightforward from parsing the PDB file, but there are some oddities / potential bugs.

    For example, looking at `10mh`:
    1. 2 DNA molecules are included as chains and the protein is classified as a trimer.
    This is debatable, but reasonable, since the protein is binding something, and shouldn't be treated as a homomer.
    2. The chain IDs in the `pkl` are 26 (protein), 27 (DNA), 28 (DNA).
    There are some heteroatoms but unclear where these numbers come from. Probably not important that they are so high?
    """

    aatype = "aatype"  # (P, ) AA sequence residue indices
    atom_positions = "atom_positions"  # (P, 37, 3) all atom positions
    atom_mask = "atom_mask"  # (P, 37) all atoms to consider
    bb_mask = "bb_mask"  # (P, ) alpha carbons considered
    bb_positions = "bb_positions"  # (P, 3) alpha carbon
    residue_index = "residue_index"  # (P, ) residue index
    chain_index = "chain_index"  # (P, ) chain index
    b_factors = "b_factors"  # (P, 37) b factors
    modeled_idx = "modeled_idx"  # (N, ) index of modeled residues


class DatasetTransformColumns(StrEnum):
    """
    Columns generated by OpenFold data transform
    """

    # atom37_to_frames()
    rigidgroups_gt_frames = "rigidgroups_gt_frames"
    rigidgroups_gt_exists = "rigidgroups_gt_exists"
    rigidgroups_group_exists = "rigidgroups_group_exists"
    rigidgroups_group_is_ambiguous = "rigidgroups_group_is_ambiguous"
    rigidgroups_alt_gt_frames = "rigidgroups_alt_gt_frames"
    # atom37_to_torsion_angles()
    torsion_angles_sin_cos = "torsion_angles_sin_cos"


class MetricName(StrEnum):
    """
    Enumeration of metrics we calculate for protein structures, sequences, and trajectories
    """

    # Functions that parse structures / sequences / trajectories

    # ca-ca metrics
    ca_ca_deviation = "ca_ca_deviation"
    ca_ca_valid_percent = "ca_ca_valid_percent"
    num_ca_ca_clashes = "num_ca_ca_clashes"

    # aatype metrics
    aatype_histogram_dist = "aatype_histogram_dist"

    # mdtraj metrics
    non_coil_percent = "non_coil_percent"
    coil_percent = "coil_percent"
    helix_percent = "helix_percent"
    strand_percent = "strand_percent"
    radius_of_gyration = "radius_of_gyration"

    # Assessment pipeline

    # `parse_pdb_feats()` and `parse_chain_feats()` are called when parsing structures
    # see DatasetProteinColumns

    # metadata
    sample_id = "sample_id"  # unique identifier for sample
    sample_length = "sample_length"  # length of sample

    # sequence + structure information
    header = "header"  # sequence name, header in fasta file
    sequence = "sequence"  # sequence of amino acids
    sample_pdb_path = "sample_pdb_path"  # filepath to generated pdb file
    folded_pdb_path = "folded_path"  # filepath to folded pdb file

    # assess folded structures
    plddt_mean = "plddt_mean"  # mean pLDDT score

    # structure comparison
    # RMSD generated sample -> folded structure
    bb_rmsd_folded = "bb_rmsd"
    # designability of structure, i.e. RMSD < 2.0
    is_designable = "is_designable"
    # RMSD generated sample -> ground truth (if true_bb_positions provided)
    bb_rmsd_gt = "bb_rmsd_gt"
    # RMSD folded structure -> ground truth structure (if true_bb_positions provided)
    bb_rmsd_folded_gt = "bb_rmsd_folded_gt"
    # (inpainting) RMSD of fixed motifs, generated sample -> folded structure
    motif_bb_rmsd_folded = "motif_bb_rmsd_folded"
    # (inpainting) RMSD of fixed motifs, generated sample -> GT
    motif_bb_rmsd_gt = "motif_bb_rmsd_gt"  # RMSD of fixed motifs to ground truth
    # (inpainting) RMSD of fixed motifs, folded structure -> GT
    motif_bb_rmsd_folded_gt = (
        "motif_bb_rmsd_folded_gt"  # RMSD of fixed motifs after folding to ground truth
    )

    # sequence recovery
    # gt => ground truth true_aa provided
    # inverse folded sequence -> predicted sequence recovery (only for designability df)
    inverse_folding_sequence_recovery_pred = "inverse_folding_sequence_recovery_pred"
    # either predicted or inverse folded sequence recovery with ground truth sequence
    inverse_folding_sequence_recovery_gt = "inverse_folding_sequence_recovery_gt"
    # (inpainting) sequence recovery of fixed motifs
    motif_sequence_recovery = "motif_sequence_recovery"
    # (inpainting) sequence recovery of fixed motifs after inverse folding
    motif_inverse_folding_sequence_recovery = "motif_inverse_folding_sequence_recovery"

    # summary metrics for inverse folding + folding
    # counts
    num_inverse_folded = "num_inverse_folded"
    num_designable = "num_designable"
    # codesign
    inverse_folding_sequence_recovery_mean = "inverse_folding_sequence_recovery_mean"
    inverse_folding_sequence_recovery_max = "inverse_folding_sequence_recovery_max"
    inverse_folding_bb_rmsd_single_seq = "inverse_folding_bb_rmsd_single_seq"
    inverse_folding_bb_rmsd_min = "inverse_folding_bb_rmsd_min"
    inverse_folding_bb_rmsd_mean = "inverse_folding_bb_rmsd_mean"
    # inpainting
    inverse_folding_motif_sequence_recovery_mean = (
        "inverse_folding_motif_sequence_recovery_mean"
    )
    inverse_folding_motif_bb_rmsd_mean = "inverse_folding_motif_bb_rmsd_mean"


# TODO - consider a SummaryMetricName enum


class OutputFileName(StrEnum):
    # input PDB
    true_structure_pdb = "true.pdb"
    true_sequence_fa = "true.fasta"

    # trajectory
    sample_pdb = "sample.pdb"
    bb_traj_pdb = "bb_traj.pdb"
    x0_traj_pdb = "x0_traj.pdb"
    aa_traj_fa = "aa_traj.fasta"
    logits_traj_anim = "logits_traj.gif"

    # folding validation
    sample_sequence_fa = "sample.fasta"
    # inverse_folded_fa determined by MPNN, matches sample name
    # inverse_folded_fa = "inverse_fold.fasta"
    # folded_pdb_path determined by alphafold + model we use
    # folded_pdb_path = "folded.pdb"

    # sample summaries / top samples
    top_sample_json = "top_samples.json"
    codesign_df = "codesign.csv"
    designability_df = "designability.csv"

    # all samples + metrics
    all_top_samples_df = "all_top_samples.csv"
    designable_metrics_df = "designable_metrics.csv"
    forward_fold_metrics_df = "forward_fold_metrics.csv"
    inverse_fold_metrics_df = "inverse_fold_metrics.csv"
