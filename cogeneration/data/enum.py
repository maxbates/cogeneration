from cogeneration.util.base_classes import StrEnum


class DatasetColumns(StrEnum):
    """Columns in the training/synthetic/redesign/test metadata CSVs"""

    pdb_name = "pdb_name"
    raw_path = "raw_path"  # original PDB file (optional)
    processed_path = "processed_path"  # pkl file
    quaternary_category = "quaternary_category"
    oligomeric_count = "oligomeric_count"  # num non-unique sequences
    oligomeric_detail = "oligomeric_detail"  # per-unique seq details
    num_chains = "num_chains"
    seq_len = "seq_len"  # total number of atoms
    modeled_seq_len = "modeled_seq_len"  # max - min res number
    moduled_num_res = "moduled_num_res"  # (new) num residues in modeled structure
    coil_percent = "coil_percent"
    helix_percent = "helix_percent"
    strand_percent = "strand_percent"
    radius_gyration = "radius_gyration"

    # TODO add in process_pdb_files
    resolution = "resolution"
    structure_method = "structure_method"

    # cluster metadata (added by loading clusters csv)
    cluster = "cluster"

    # redesign columns
    example = "example"
    best_seq = "best_seq"  # best 1 redesign per structure
    best_rmsd = "best_rmsd"

    # added during load
    index = "index"


class DatasetProteinColumns(StrEnum):
    """
    Information about the protein, pickled in `processed_path`, or from parsing a Protein / Chain.
    Most of these values are defined by `process_chain` and `parse_chain_feats`.

    Most fields and values seem straightforward from parsing the PDB file, but there are some oddities / potential bugs.

    For example, looking at `10mh`:
    1. 2 DNA molecules are included as chains and the protein is classified as a trimer.
    This is debatable, but reasonable, since the protein is binding something, and shouldn't be treated as a homomer.
    2. The chain IDs in the `pkl` are 26 (protein), 27 (DNA), 28 (DNA).
    There are some heteroatoms but unclear where these numbers come from. Probably not important that they are so high?

    """

    aatype = "aatype"  # AA sequence (N, )
    atom_positions = "atom_positions"  # all atom, (N, 37, 3)
    atom_mask = "atom_mask"  # all atom (N, 37)
    bb_mask = "bb_mask"  # alpha carbon  (N, )
    bb_positions = "bb_positions"  # alpha carbon (N, 3)
    residue_index = "residue_index"  # residue index (N, )
    chain_index = "chain_index"  # chain index (N, )
    b_factors = "b_factors"  # b factors (N, 37)
    modeled_idx = "modeled_idx"  # index of modeled residues (dropped in processing) i.e. in mask (N, )


class DatasetTransformColumns(StrEnum):
    """
    Columns generated by OpenFold data transform
    """

    # atom37_to_frames()
    rigidgroups_gt_frames = "rigidgroups_gt_frames"
    rigidgroups_gt_exists = "rigidgroups_gt_exists"
    rigidgroups_group_exists = "rigidgroups_group_exists"
    rigidgroups_group_is_ambiguous = "rigidgroups_group_is_ambiguous"
    rigidgroups_alt_gt_frames = "rigidgroups_alt_gt_frames"
    # atom37_to_torsion_angles()
    torsion_angles_sin_cos = "torsion_angles_sin_cos"


class MetricName(StrEnum):
    """
    Enumeration of metrics we calculate for protein structures, sequences, and trajectories
    """

    # Functions that parse structures / sequences / trajectories

    # ca-ca metrics
    ca_ca_deviation = "ca_ca_deviation"
    ca_ca_valid_percent = "ca_ca_valid_percent"
    num_ca_ca_clashes = "num_ca_ca_clashes"

    # aatype metrics
    aatype_histogram_dist = "aatype_histogram_dist"

    # mdtraj metrics
    non_coil_percent = "non_coil_percent"
    coil_percent = "coil_percent"
    helix_percent = "helix_percent"
    strand_percent = "strand_percent"
    radius_of_gyration = "radius_of_gyration"

    # Assessment pipeline

    # `parse_pdb_feats()` and `parse_chain_feats()` are called when parsing structures
    # see DatasetProteinColumns

    # metadata
    sample_id = "sample_id"  # unique identifier for sample
    sample_length = "sample_length"  # length of sample

    # sequence + structure information
    header = "header"  # sequence name, header in fasta file
    sequence = "sequence"  # sequence of amino acids
    sample_pdb_path = "sample_pdb_path"  # filepath to generated pdb file
    folded_pdb_path = "folded_path"  # filepath to folded pdb file

    # assess folded structures
    plddt_mean = "plddt_mean"  # mean pLDDT score

    # structure comparison
    # gt => ground truth true_bb_positions provided
    bb_rmsd = "bb_rmsd"  # generated sample to folded structure
    is_designable = "is_designable"  # designability of structure, i.e. RMSD < 2.0
    # generated sample to ground truth structure (if provided)
    bb_rmsd_gt = "bb_rmsd_gt"
    # folded structure to ground truth structure (if provided)
    bb_rmsd_folded_gt = "bb_rmsd_folded_gt"

    # sequence recovery
    # gt => ground truth true_aa provided
    # inverse folded sequence -> predicted sequence recovery (only for designability df)
    inverse_folding_sequence_recovery_pred = "inverse_folding_sequence_recovery_pred"
    # either predicted or inverse folded sequence recovery with ground truth sequence
    inverse_folding_sequence_recovery_gt = "inverse_folding_sequence_recovery_gt"

    # inverse + forward folding summary metrics
    inverse_folding_sequence_recovery_mean = "inverse_folding_sequence_recovery_mean"
    inverse_folding_sequence_recovery_max = "inverse_folding_sequence_recovery_max"
    inverse_folding_bb_rmsd_single_seq = "inverse_folding_bb_rmsd_single_seq"
    inverse_folding_bb_rmsd_min = "inverse_folding_bb_rmsd_min"
    inverse_folding_bb_rmsd_mean = "inverse_folding_bb_rmsd_mean"
    num_inverse_folded = "num_inverse_folded"
    num_designable = "num_designable"


class OutputFileName(StrEnum):
    # trajectory
    sample_pdb = "sample.pdb"
    bb_traj_pdb = "bb_traj.pdb"
    x0_traj_pdb = "x0_traj.pdb"
    aa_traj_fa = "aa_traj.fasta"
    logits_traj_anim = "logits_traj.gif"

    # folding validation
    sample_sequence_fa = "sample.fasta"
    true_sequence_fa = "true.fasta"
    # inverse_folded_fa determined by MPNN, matches sample name
    # inverse_folded_fa = "inverse_fold.fasta"
    # folded_pdb_path determined by alphafold + model we use
    # folded_pdb_path = "folded.pdb"

    # sample summaries / top samples
    top_sample_json = "top_samples.json"
    codesign_df = "codesign.csv"
    designability_df = "designability.csv"

    # all samples + metrics
    all_top_samples_df = "all_top_samples.csv"
    designable_metrics_df = "designable_metrics.csv"
    forward_fold_metrics_df = "forward_fold_metrics.csv"
    inverse_fold_metrics_df = "inverse_fold_metrics.csv"
